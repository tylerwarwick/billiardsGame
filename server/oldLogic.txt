Some server methods:
# Get the animation frames
        # May come back and update db to indicate that we've seen this frame or something to that affect
        # I could even just compare on backend of shoot POST as well but we'll see
        elif parsedPath.startswith('/table'):
            # Get tableId 
            tableId = parsedPath.split('/')[-1]
            print(tableId) 
            
            db = p.Database()
            response = db.readTable(tableId).svg()
            db.close()
            
            # Set headers
            self.send_response( 200 ); # OK
            self.send_header( "Content-type", "text/html" );
            self.send_header( "Content-length", len(response));
            self.end_headers(); 

            self.wfile.write(response.encode("utf-8"))


Old game js logic
const animate = (start, end) => {
    // Need to request table from server over interval of IDs and cast to screen
    let i = start
    
    toggleAnimationOn(true)    
    
    while (i<= end){
        getFrame(i)
        .then((response) => {
            $('#animation').empty()
            setTimeout(() => { $('#animation').html(response)}, 40)
            
        })
        .catch((error) => {
            console.log("Broken frame retrieval")
        })
        i++
    }   
    
    $('#interactiveGame').empty()
    $('#interactiveGame').html()
    

    const animateFrame = () => {
        if (i <= end) {
            getFrame(i)
                .then((response) => {
                    $('#animation').html(response);
                    i++;
                    requestAnimationFrame(animateFrame); // Request the next frame
                })
                .catch((error) => {
                    console.log("Broken frame retrieval");
                });
        } else {
            toggleAnimationOn(false); // Animation complete
        }
    };

    animateFrame(); // Start the animation loop
}



old database (writeTable) logic
cur.execute("INSERT INTO Ball (BALLNO, XPOS, YPOS, XVEL, YVEL) VALUES (?, ?, ?, ?, ?) RETURNING BALLID;", (ball.number,
                                                                                                                           ball.pos.x,
                                                                                                                           ball.pos.y,
                                                                                                                           velX,
                                                                                                                           velY))

                ballId = cur.fetchone()[0]

                # Put ball into BallTable
                cur.execute("INSERT INTO BallTable (BALLID, TABLEID) VALUES (?, ?)", (ballId, tableId)) 

method for shot interval we don't use anymore
def shotInterval(self, shotId):
        query = """
                SELECT 
                    (SELECT TABLEID 
                    FROM TableShot 
                    WHERE SHOTID = ?
                    ORDER BY TABLEID ASC 
                    LIMIT 1) AS lowest_tableId,
                    (SELECT TABLEID 
                    FROM TableShot 
                    WHERE SHOTID = ? 
                    ORDER BY TABLEID DESC 
                    LIMIT 1) AS highest_tableId
                """
        
        cur = self.conn.cursor()
        data = cur.execute(query, (shotId, shotId)).fetchone()

        return data


def oldShoot(self, gameName, playerName, table, xvel, yvel):
        # If table is None, we can't do anything
        if (table is None):
            return None

        # Get db instance
        db = Database()

        # Add entry to shot table in db and get shotId
        shotId = db.newShot(self.gameID, playerName)

        # Get cue ball
        [cueBall, xPos, yPos] = table.cueBall()

        # Store parameters across type conversion
        cueBall.type = phylib.PHYLIB_ROLLING_BALL

        # Refresh values of newly typecast cue ball
        cueBall.obj.rolling_ball.number = 0 
        cueBall.obj.rolling_ball.pos.x = xPos
        cueBall.obj.rolling_ball.pos.y = yPos
        cueBall.obj.rolling_ball.vel.x = xvel
        cueBall.obj.rolling_ball.vel.y = yvel

        # Get vector magnitude for speed
        speed = m.sqrt((xvel * xvel) + (yvel * yvel))

        # Only set non-zero acceleration if speed > epsilon
        xAcc = ((-xvel / speed)  * DRAG) if (speed > phylib.PHYLIB_VEL_EPSILON) else 0
        yAcc = ((-yvel / speed)  * DRAG) if (speed > phylib.PHYLIB_VEL_EPSILON) else 0
  
        cueBall.obj.rolling_ball.acc.x = xAcc 
        cueBall.obj.rolling_ball.acc.y = yAcc

        # Tack on svg header
        svg = HEADER 

        # Fill in segment gaps
        while (table):
            # Save original time
            startTime = table.time

            # Save old table to simulate from as well
            startTable = table

            # Run segment and get updated table
            table = table.segment()

            # Check if we are done iterating
            if (table is None):
                break 
            
            # Get time elapsed and number of frames
            frames = m.floor((table.time - startTime) / FRAME_INTERVAL)

            # Make a table for each frame in this segment of time
            for i in range(0, frames+1):
                # Get new table with roll applied
                newTable = startTable.roll(i * FRAME_INTERVAL)
              
                # Set its time correctly
                newTable.time = startTime + (i * FRAME_INTERVAL)

                # Write this table to db
                newTableId = db.writeTable(newTable)

                # Tack svg frame onto reel
                svg = svg +  "<g class='hidden frame' >" + newTable.svg(False) + "</g>\n"

                # Also record it in tableshot table
                db.tableShot(newTableId, shotId)

                # Provided roll function does not cast deaccelerating balls to still
                # Must include actual frame sent by C segment function
                if (i == frames):
                    # Save table with updated state in db
                    lastTableId = db.writeTable(table)
                    db.tableShot(lastTableId, shotId)
                    svg = svg +  "<g class='hidden frame' >" + table.svg(False) + "</g>\n"

        

        # Commit and close
        db.conn.commit()
        db.close()

        # Tack on footer
        svg = svg + FOOTER

        print("SHOOT FINSIHED!!!")
        # Return shotId to make it easiest on server side
        # Update: return massive svg with frames as well
        return shotId, svg


const getFrame = (tableId) => {
    // Need to wrap as promise
    return new Promise((resolve, reject) => {
        $.ajax({
            url: `/table/${tableId}`,
            method: 'GET',
            contentType: 'application/json',
            success: (response) => {
                return resolve(response)
            },
            error: (response) => {
                reject(response)
            }
        })
    }) 
}


 else if (currentFrame.hasClass('turnUpdate')){
                console.log(parseInt(currentFrame.html()))
                whosTurn = parseInt(currentFrame.html())
            }